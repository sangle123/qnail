!function () { "use strict"; var t, e, i, n; function r(t) { if (void 0 === t) throw Error('Pathformer [constructor]: "element" parameter is required'); if (t.constructor === String && !(t = document.getElementById(t))) throw Error('Pathformer [constructor]: "element" parameter is not related to an existing ID'); if (!(t instanceof window.SVGElement || t instanceof window.SVGGElement || /^svg$/i.test(t.nodeName))) throw Error('Pathformer [constructor]: "element" parameter must be a string or a SVGelement'); this.el = t, this.scan(t) } function s(e, i, n) { t(), this.isReady = !1, this.setElement(e, i), this.setOptions(i), this.setCallback(n), this.isReady && this.init() } r.prototype.TYPES = ["line", "ellipse", "circle", "polygon", "polyline", "rect",], r.prototype.ATTR_WATCH = ["cx", "cy", "points", "r", "rx", "ry", "x", "x1", "x2", "y", "y1", "y2",], r.prototype.scan = function (t) { for (var e, i, n, r = t.querySelectorAll(this.TYPES.join(",")), s = 0; s < r.length; s++)i = (0, this[(e = r[s]).tagName.toLowerCase() + "ToPath"])(this.parseAttr(e.attributes)), n = this.pathMaker(e, i), e.parentNode.replaceChild(n, e) }, r.prototype.lineToPath = function (t) { var e = {}, i = t.x1 || 0, n = t.y1 || 0, r = t.x2 || 0, s = t.y2 || 0; return e.d = "M" + i + "," + n + "L" + r + "," + s, e }, r.prototype.rectToPath = function (t) { var e = {}, i = parseFloat(t.x) || 0, n = parseFloat(t.y) || 0, r = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0; if (t.rx || t.ry) { var a = parseInt(t.rx, 10) || -1, o = parseInt(t.ry, 10) || -1; a = Math.min(Math.max(a < 0 ? o : a, 0), r / 2), o = Math.min(Math.max(o < 0 ? a : o, 0), s / 2), e.d = "M " + (i + a) + "," + n + " L " + (i + r - a) + "," + n + " A " + a + "," + o + ",0,0,1," + (i + r) + "," + (n + o) + " L " + (i + r) + "," + (n + s - o) + " A " + a + "," + o + ",0,0,1," + (i + r - a) + "," + (n + s) + " L " + (i + a) + "," + (n + s) + " A " + a + "," + o + ",0,0,1," + i + "," + (n + s - o) + " L " + i + "," + (n + o) + " A " + a + "," + o + ",0,0,1," + (i + a) + "," + n } else e.d = "M" + i + " " + n + " L" + (i + r) + " " + n + " L" + (i + r) + " " + (n + s) + " L" + i + " " + (n + s) + " Z"; return e }, r.prototype.polylineToPath = function (t) { var e, i, n = {}, r = t.points.trim().split(" "); if (-1 === t.points.indexOf(",")) { var s = []; for (e = 0; e < r.length; e += 2)s.push(r[e] + "," + r[e + 1]); r = s } for (i = "M" + r[0], e = 1; e < r.length; e++)-1 !== r[e].indexOf(",") && (i += "L" + r[e]); return n.d = i, n }, r.prototype.polygonToPath = function (t) { var e = r.prototype.polylineToPath(t); return e.d += "Z", e }, r.prototype.ellipseToPath = function (t) { var e = {}, i = parseFloat(t.rx) || 0, n = parseFloat(t.ry) || 0, r = parseFloat(t.cx) || 0, s = parseFloat(t.cy) || 0, a = r - i, o = parseFloat(r) + parseFloat(i), h = s; return e.d = "M" + a + "," + s + "A" + i + "," + n + " 0,1,1 " + o + "," + h + "A" + i + "," + n + " 0,1,1 " + a + "," + h, e }, r.prototype.circleToPath = function (t) { var e = {}, i = parseFloat(t.r) || 0, n = parseFloat(t.cx) || 0, r = parseFloat(t.cy) || 0, s = n - i, a = parseFloat(n) + parseFloat(i), o = r; return e.d = "M" + s + "," + r + "A" + i + "," + i + " 0,1,1 " + a + "," + o + "A" + i + "," + i + " 0,1,1 " + s + "," + o, e }, r.prototype.pathMaker = function (t, e) { var i, n, r = document.createElementNS("http://www.w3.org/2000/svg", "path"); for (i = 0; i < t.attributes.length; i++)n = t.attributes[i], -1 === this.ATTR_WATCH.indexOf(n.name) && r.setAttribute(n.name, n.value); for (i in e) r.setAttribute(i, e[i]); return r }, r.prototype.parseAttr = function (t) { for (var e, i = {}, n = 0; n < t.length; n++) { if (e = t[n], -1 !== this.ATTR_WATCH.indexOf(e.name) && -1 !== e.value.indexOf("%")) throw Error("Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into 'path' tags. Please use 'viewBox'."); i[e.name] = e.value } return i }, s.LINEAR = function (t) { return t }, s.EASE = function (t) { return -Math.cos(t * Math.PI) / 2 + .5 }, s.EASE_OUT = function (t) { return 1 - Math.pow(1 - t, 3) }, s.EASE_IN = function (t) { return Math.pow(t, 3) }, s.EASE_OUT_BOUNCE = function (t) { var e = Math.pow(1 - t, 2); return 1 - e + (1 - Math.abs(Math.cos(Math.pow(1 - Math.cos(t * (.5 * Math.PI)), 1.5) * (2.5 * Math.PI)))) * e }, s.prototype.setElement = function (t, e) { var i, n; if (void 0 === t) throw Error('Vivus [constructor]: "element" parameter is required'); if (t.constructor === String && !(t = document.getElementById(t))) throw Error('Vivus [constructor]: "element" parameter is not related to an existing ID'); if (this.parentEl = t, e && e.file) { n = this, i = function () { var t = document.createElement("div"); t.innerHTML = this.responseText; var i = t.querySelector("svg"); if (!i) throw Error("Vivus [load]: Cannot find the SVG in the loaded file : " + e.file); n.el = i, n.el.setAttribute("width", "100%"), n.el.setAttribute("height", "100%"), n.parentEl.appendChild(n.el), n.isReady = !0, n.init(), n = null }; var r = new window.XMLHttpRequest; return r.addEventListener("load", i), r.open("GET", e.file), void r.send() } switch (t.constructor) { case window.SVGSVGElement: case window.SVGElement: case window.SVGGElement: this.el = t, this.isReady = !0; break; case window.HTMLObjectElement: n = this, (i = function (e) { if (!n.isReady) { if (n.el = t.contentDocument && t.contentDocument.querySelector("svg"), !n.el && e) throw Error("Vivus [constructor]: object loaded does not contain any SVG"); n.el && (t.getAttribute("built-by-vivus") && (n.parentEl.insertBefore(n.el, t), n.parentEl.removeChild(t), n.el.setAttribute("width", "100%"), n.el.setAttribute("height", "100%")), n.isReady = !0, n.init(), n = null) } })() || t.addEventListener("load", i); break; default: throw Error('Vivus [constructor]: "element" parameter is not valid (or miss the "file" attribute)') } }, s.prototype.setOptions = function (t) { var e = ["delayed", "sync", "async", "nsync", "oneByOne", "scenario", "scenario-sync",], i = ["inViewport", "manual", "autostart"]; if (void 0 !== t && t.constructor !== Object) throw Error('Vivus [constructor]: "options" parameter must be an object'); if ((t = t || {}).type && -1 === e.indexOf(t.type)) throw Error("Vivus [constructor]: " + t.type + " is not an existing animation `type`"); if (this.type = t.type || e[0], t.start && -1 === i.indexOf(t.start)) throw Error("Vivus [constructor]: " + t.start + " is not an existing `start` option"); if (this.start = t.start || i[0], this.isIE = -1 !== window.navigator.userAgent.indexOf("MSIE") || -1 !== window.navigator.userAgent.indexOf("Trident/") || -1 !== window.navigator.userAgent.indexOf("Edge/"), this.duration = n(t.duration, 120), this.delay = n(t.delay, null), this.dashGap = n(t.dashGap, 1), this.forceRender = t.hasOwnProperty("forceRender") ? !!t.forceRender : this.isIE, this.reverseStack = !!t.reverseStack, this.selfDestroy = !!t.selfDestroy, this.onReady = t.onReady, this.map = [], this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null, this.ignoreInvisible = !!t.hasOwnProperty("ignoreInvisible") && !!t.ignoreInvisible, this.animTimingFunction = t.animTimingFunction || s.LINEAR, this.pathTimingFunction = t.pathTimingFunction || s.LINEAR, this.delay >= this.duration) throw Error("Vivus [constructor]: delay must be shorter than duration") }, s.prototype.setCallback = function (t) { if (t && t.constructor !== Function) throw Error('Vivus [constructor]: "callback" parameter must be a function'); this.callback = t || function () { } }, s.prototype.mapping = function () { var t, e, i, r, s, a, o, h, l, c; for (h = a = o = 0, e = this.el.querySelectorAll("path"), c = !1, t = 0; t < e.length; t++)if (i = e[t], !this.isInvisible(i)) { if (s = { el: i, length: 0, startAt: 0, duration: 0, isResizeSensitive: !1 }, "non-scaling-stroke" === i.getAttribute("vector-effect")) { var u = i.getBoundingClientRect(), p = i.getBBox(); l = Math.max(u.width / p.width, u.height / p.height), c = s.isResizeSensitive = !0 } else l = 1; s.length = Math.ceil(i.getTotalLength() * l), isNaN(s.length) ? window.console && console.warn && console.warn("Vivus [mapping]: cannot retrieve a path element length", i) : (this.map.push(s), i.style.strokeDasharray = s.length + " " + (s.length + 2 * this.dashGap), i.style.strokeDashoffset = s.length + this.dashGap, s.length += this.dashGap, a += s.length, this.renderPath(t)) } for (c && console.warn("Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info."), a = 0 === a ? 1 : a, this.delay = null === this.delay ? this.duration / 3 : this.delay, this.delayUnit = this.delay / (1 < e.length ? e.length - 1 : 1), this.reverseStack && this.map.reverse(), t = 0; t < this.map.length; t++) { switch (s = this.map[t], this.type) { case "delayed": s.startAt = this.delayUnit * t, s.duration = this.duration - this.delay; break; case "oneByOne": s.startAt = o / a * this.duration, s.duration = s.length / a * this.duration; break; case "sync": case "async": case "nsync": s.startAt = 0, s.duration = this.duration; break; case "scenario-sync": i = s.el, r = this.parseAttr(i), s.startAt = h + (n(r["data-delay"], this.delayUnit) || 0), s.duration = n(r["data-duration"], this.duration), h = void 0 !== r["data-async"] ? s.startAt : s.startAt + s.duration, this.frameLength = Math.max(this.frameLength, s.startAt + s.duration); break; case "scenario": i = s.el, r = this.parseAttr(i), s.startAt = n(r["data-start"], this.delayUnit) || 0, s.duration = n(r["data-duration"], this.duration), this.frameLength = Math.max(this.frameLength, s.startAt + s.duration) }o += s.length, this.frameLength = this.frameLength || this.duration } }, s.prototype.recalc = function () { this.mustRecalcScale || (this.mustRecalcScale = e((function () { this.performLineRecalc() }).bind(this))) }, s.prototype.performLineRecalc = function () { for (var t, e, i, n, r, s = 0; s < this.map.length; s++)(t = this.map[s]).isResizeSensitive && (i = (e = t.el).getBoundingClientRect(), n = e.getBBox(), r = Math.max(i.width / n.width, i.height / n.height), t.length = Math.ceil(e.getTotalLength() * r), e.style.strokeDasharray = t.length + " " + (t.length + 2 * this.dashGap)); this.trace(), this.mustRecalcScale = null }, s.prototype.draw = function () { var t = this; if (this.currentFrame += this.speed, this.currentFrame <= 0) this.stop(), this.reset(); else { if (!(this.currentFrame >= this.frameLength)) return this.trace(), void (this.handle = e(function () { t.draw() })); this.stop(), this.currentFrame = this.frameLength, this.trace(), this.selfDestroy && this.destroy() } this.callback(this), this.instanceCallback && (this.instanceCallback(this), this.instanceCallback = null) }, s.prototype.trace = function () { var t, e, i, n; for (n = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength, t = 0; t < this.map.length; t++)e = (n - (i = this.map[t]).startAt) / i.duration, e = this.pathTimingFunction(Math.max(0, Math.min(1, e))), i.progress !== e && (i.progress = e, i.el.style.strokeDashoffset = Math.floor(i.length * (1 - e)), this.renderPath(t)) }, s.prototype.renderPath = function (t) { if (this.forceRender && this.map && this.map[t]) { var e = this.map[t], i = e.el.cloneNode(!0); e.el.parentNode.replaceChild(i, e.el), e.el = i } }, s.prototype.init = function () { this.frameLength = 0, this.currentFrame = 0, this.map = [], new r(this.el), this.mapping(), this.starter(), this.onReady && this.onReady(this) }, s.prototype.starter = function () { switch (this.start) { case "manual": return; case "autostart": this.play(); break; case "inViewport": var t = this, e = function () { t.isInViewport(t.parentEl, 1) && (t.play(), window.removeEventListener("scroll", e)) }; window.addEventListener("scroll", e), e() } }, s.prototype.getStatus = function () { return 0 === this.currentFrame ? "start" : this.currentFrame === this.frameLength ? "end" : "progress" }, s.prototype.reset = function () { return this.setFrameProgress(0) }, s.prototype.finish = function () { return this.setFrameProgress(1) }, s.prototype.setFrameProgress = function (t) { return t = Math.min(1, Math.max(0, t)), this.currentFrame = Math.round(this.frameLength * t), this.trace(), this }, s.prototype.play = function (t, e) { if (this.instanceCallback = null, t && "function" == typeof t) this.instanceCallback = t, t = null; else if (t && "number" != typeof t) throw Error("Vivus [play]: invalid speed"); return e && "function" == typeof e && !this.instanceCallback && (this.instanceCallback = e), this.speed = t || 1, this.handle || this.draw(), this }, s.prototype.stop = function () { return this.handle && (i(this.handle), this.handle = null), this }, s.prototype.destroy = function () { var t, e; for (this.stop(), t = 0; t < this.map.length; t++)(e = this.map[t]).el.style.strokeDashoffset = null, e.el.style.strokeDasharray = null, this.renderPath(t) }, s.prototype.isInvisible = function (t) { var e, i = t.getAttribute("data-ignore"); return null !== i ? "false" !== i : !!this.ignoreInvisible && !(e = t.getBoundingClientRect()).width && !e.height }, s.prototype.parseAttr = function (t) { var e, i = {}; if (t && t.attributes) for (var n = 0; n < t.attributes.length; n++)i[(e = t.attributes[n]).name] = e.value; return i }, s.prototype.isInViewport = function (t, e) { var i = this.scrollY(), n = i + this.getViewportH(), r = t.getBoundingClientRect(), s = r.height, a = i + r.top; return a + s * (e = e || 0) <= n && i <= a + s }, s.prototype.getViewportH = function () { var t = this.docElem.clientHeight, e = window.innerHeight; return t < e ? e : t }, s.prototype.scrollY = function () { return window.pageYOffset || this.docElem.scrollTop }, t = function () { s.prototype.docElem || (s.prototype.docElem = window.document.documentElement, e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60) }, i = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (t) { return window.clearTimeout(t) }) }, n = function (t, e) { var i = parseInt(t, 10); return 0 <= i ? i : e }, "function" == typeof define && define.amd ? define([], function () { return s }) : "object" == typeof exports ? module.exports = s : window.Vivus = s }(); const container = document.querySelectorAll(".dsm-svg-animation-container"); function handleAnimation(t, e, i, n, r, s, a = 1, o = 1) { setTimeout(() => { let h = new Vivus(t, { type: n, duration: e, animTimingFunction: Vivus.timingFunction }); h.play(() => { r && (h.destroy(), handleAnimation(t, e, i, n, r, s)), a > 1 && o < a && (h.destroy(), handleAnimation(t, e, i, n, r, s, a, o + 1)) }) }, i) } function isInViewport(t) { let { svgEle: e, visibleViewportRatio: i, speed: n, finalDelay: r, animationType: s, loopEle: a, timingFunction: o, noOfTimes: h } = t, l = { root: document.querySelector("#scrollArea"), rootMargin: "0px", threshold: [.1, .15, .2, .25, .3, .35, .4, .45, .5, .55, .6, .65, .7, .75, .8, .85, .9, .95, 1,] }; new IntersectionObserver((t, l) => { t.forEach(t => { Math.round(100 * t.intersectionRatio) >= i && (handleAnimation(e, n, r, s, a, o, h), 0 === r ? e.classList.add("dsm-svg-visible") : setTimeout(() => { e.classList.add("dsm-svg-visible") }, r), l.disconnect()) }) }, l).observe(e) } container.forEach((t, e) => { let i = Number(t.dataset.speed), n = Number(t.dataset.delay), r = n, s = t.dataset.animation_type, a = t.dataset.loop, o = t.dataset.unlimited, h = t.dataset.count, l = t.dataset.trigger_type, c = t.dataset.animation_timing_func.toUpperCase(), u = t.querySelector("svg"), p = t.dataset.visibleviewport, d = Number(p.substring(0, p.length - 1)), m = "on" === a && "on" === o, f = "on" === a && "off" === o ? Number(h) : 1, y = { svgEle: u, speed: i, finalDelay: r, animationType: s, loopEle: m, timingFunction: c, noOfTimes: f, visibleViewportRatio: d }; "dsm_viewport" === l && isInViewport(y), u.addEventListener("click", () => { "dsm_click" === l && handleAnimation(u, i, r, s, m, c, f) }), u.addEventListener("mouseover", () => { "dsm_hover" === l && handleAnimation(u, i, r, s, m, c, f) }) });